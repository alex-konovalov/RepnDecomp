% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage[top=37mm,bottom=37mm,left=27mm,right=27mm]{geometry}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{ RepnDecomp \mbox{}}}\\
\vfill

\hypersetup{pdftitle= RepnDecomp }
\markright{\scriptsize \mbox{}\hfill  RepnDecomp  \hfill\mbox{}}
{\Huge \textbf{ Decompose representations of finite groups into irreducibles \mbox{}}}\\
\vfill

{\Huge  0.1 \mbox{}}\\[1cm]
{ 20 April 2019 \mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Kaashif Hymabaccus\\
   \mbox{}}}\\
\hypersetup{pdfauthor= Kaashif Hymabaccus\\
   }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Kaashif Hymabaccus\\
   }  Email: \href{mailto://kaashif@kaashif.co.uk} {\texttt{kaashif@kaashif.co.uk}}\\
  Homepage: \href{https://kaashif.co.uk} {\texttt{https://kaashif.co.uk}}}\\
\end{titlepage}

\newpage\setcounter{page}{2}
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 1 ]}}

\tableofcontents
\newpage

     
\chapter{\textcolor{Chapter }{Introduction}}\label{Chapter_Introduction}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  
\section{\textcolor{Chapter }{Getting started with RepnDecomp}}\label{Chapter_Introduction_Section_Getting_started_with_RepnDecomp}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X789233A47A277072}{}
{
  This package allows computations of various decompositions of a representation $\rho : G \to GL(V)$ where $G$ is finite and $V$ is a finite-dimensional $\mathbb{C}$-vector space. The algorithms implemented can be divided into two groups:
methods due to Serre from his book Linear Representations of Finite Groups,
and original methods due to the authors of this package. 

 The default is to use the algorithms due to Serre. If you pass the option \texttt{method := "alternate"} to a function, it will use the alternate method. Passing the option \texttt{parallel} will try to compute in parallel as much as possible. See the individual
functions for options you can pass. 

 The main functions implemented in this package are: 

 For decomposing representations into canonical and irreducible direct
summands: 

 
\begin{itemize}
\item  \texttt{CanonicalDecomposition} (\ref{CanonicalDecomposition}) 
\item  \texttt{IrreducibleDecomposition} (\ref{IrreducibleDecomposition}) 
\item  \texttt{IrreducibleDecompositionCollected} (\ref{IrreducibleDecompositionCollected}) 
\end{itemize}
 

 For block diagonalising representations: 

 
\begin{itemize}
\item  \texttt{BlockDiagonalBasisOfRepresentation} (\ref{BlockDiagonalBasisOfRepresentation}) 
\item  \texttt{BlockDiagonalRepresentation} (\ref{BlockDiagonalRepresentation}) 
\end{itemize}
 

 For computing centraliser rings: 

 
\begin{itemize}
\item  \texttt{CentralizerBlocksOfRepresentation} (\ref{CentralizerBlocksOfRepresentation}) 
\item  \texttt{CentralizerOfRepresentation} (\ref{CentralizerOfRepresentation}) 
\end{itemize}
 

 For testing isomorphism and computing isomorphisms (intertwining operators)
between representations: 

 
\begin{itemize}
\item  \texttt{LinearRepresentationIsomorphism} (\ref{LinearRepresentationIsomorphism}) 
\item  \texttt{AreRepsIsomorphic} (\ref{AreRepsIsomorphic}) 
\item  \texttt{IsLinearRepresentationIsomorphism} (\ref{IsLinearRepresentationIsomorphism}) 
\end{itemize}
 

 For testing unitarity of representations and the unitarisation of
representations: 

 
\begin{itemize}
\item  \texttt{UnitaryRepresentation} (\ref{UnitaryRepresentation}) 
\item  \texttt{IsUnitaryRepresentation} (\ref{IsUnitaryRepresentation}) 
\end{itemize}
 }

 }

   
\chapter{\textcolor{Chapter }{Isomorphisms between representations}}\label{Chapter_Isomorphisms_between_representations}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7D9B253E794EF912}{}
{
  
\section{\textcolor{Chapter }{Finding explicit isomorphisms}}\label{Chapter_Isomorphisms_between_representations_Section_Finding_explicit_isomorphisms}
\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7AEE81C2809E0B98}{}
{
  

\subsection{\textcolor{Chapter }{LinearRepresentationIsomorphism}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X7F0D3CFB7800149A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LinearRepresentationIsomorphism({\mdseries\slshape rho, tau[, rho{\textunderscore}cent{\textunderscore}basis, tau{\textunderscore}cent{\textunderscore}basis]})\index{LinearRepresentationIsomorphism@\texttt{LinearRepresentationIsomorphism}}
\label{LinearRepresentationIsomorphism}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A matrix $A$ or fail 



 Let $\rho : G \to GL(V)$ and $\tau : G \to GL(W)$. If there exists a linear map $A : V \to W$ such that for all $g \in G$, $\tau(g)A = A\rho(g)$, this function returns one such $A$. $A$ is the isomorphism between the representations. If the representations are not
isomorphic, then fail is returned. 

 There are three methods that we can use to compute an isomorphism of linear
representations, you can select one by passing options to the function. 

 
\begin{itemize}
\item  \texttt{use{\textunderscore}kronecker}: Assumes the matrices are small enough that their Kronecker products can fit
into memory. Uses \texttt{GroupSumBSGS} (\ref{GroupSumBSGS}) and \texttt{KroneckerProduct} to compute an element of the fixed subspace of $\rho \otimes \tau^*$. 
\end{itemize}
 

 
\begin{itemize}
\item  \texttt{use{\textunderscore}orbit{\textunderscore}sum}: Finds an isomorphism by summing orbits of the the action of $\rho \otimes \tau^*$ on matrices. Note that orbits could be very large, so this could be as bad as
summing over the whole group. 
\end{itemize}
 

 
\begin{itemize}
\item  The default, sums over the whole group to compute the projection onto the
fixed subspace. 
\end{itemize}
 }

 

\subsection{\textcolor{Chapter }{LinearRepresentationIsomorphismSlow}}
\logpage{[ 2, 1, 2 ]}\nobreak
\hyperdef{L}{X841DE7D08491325F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LinearRepresentationIsomorphismSlow({\mdseries\slshape rho, tau})\index{LinearRepresentationIsomorphismSlow@\texttt{LinearRepresentationIsomorphismSlow}}
\label{LinearRepresentationIsomorphismSlow}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A matrix $A$ or fail 



 Gives the same result as \texttt{LinearRepresentationIsomorphism} (\ref{LinearRepresentationIsomorphism}), but this function uses a simpler method which always involves summing over $G$, without using \texttt{GroupSumBSGS} (\ref{GroupSumBSGS}). This might be useful in some cases if computing a good BSGS is difficult.
However, for all cases that have been tested, it is slow (as the name
suggests). }

 }

 
\section{\textcolor{Chapter }{Testing isomorphisms}}\label{Chapter_Isomorphisms_between_representations_Section_Testing_isomorphisms}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X85DAC9E583D8EFB9}{}
{
  Since representations of finite groups over $\mathbb{C}$ are determined by their characters, it is easy to check whether two
representations are isomorphic by checking if they have the same character. We
try to use characters wherever possible. 

\subsection{\textcolor{Chapter }{AreRepsIsomorphic}}
\logpage{[ 2, 2, 1 ]}\nobreak
\hyperdef{L}{X86EB9DD586958473}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{AreRepsIsomorphic({\mdseries\slshape rho, tau})\index{AreRepsIsomorphic@\texttt{AreRepsIsomorphic}}
\label{AreRepsIsomorphic}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true if \mbox{\texttt{\mdseries\slshape rho}} and \mbox{\texttt{\mdseries\slshape tau}} are isomorphic as representations, false otherwise. 



 

 }

 

\subsection{\textcolor{Chapter }{IsLinearRepresentationIsomorphism}}
\logpage{[ 2, 2, 2 ]}\nobreak
\hyperdef{L}{X81080E1B7917B361}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsLinearRepresentationIsomorphism({\mdseries\slshape A, rho, tau})\index{IsLinearRepresentationIsomorphism@\texttt{IsLinearRepresentationIsomorphism}}
\label{IsLinearRepresentationIsomorphism}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true if \mbox{\texttt{\mdseries\slshape rho}} and \mbox{\texttt{\mdseries\slshape tau}} are isomorphic as as representations with the isomorphism given by the linear
map \mbox{\texttt{\mdseries\slshape A}} 



 This function tests if, for all $g \in G$, $A \rho(g) = \tau(g) A$. That is, true is returned iff $A$ is the intertwining operator taking $\rho$ to $\tau$. Note that it is always the case that: as long as an isomorphism between the
given representations actually exists. }

 }

 }

   
\chapter{\textcolor{Chapter }{Algorithms for unitary representations}}\label{Chapter_Algorithms_for_unitary_representations}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X83B4D1DB7F92BD3A}{}
{
  
\section{\textcolor{Chapter }{Unitarising representations}}\label{Chapter_Algorithms_for_unitary_representations_Section_Unitarising_representations}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X870B3D0D80CFADB1}{}
{
  

\subsection{\textcolor{Chapter }{UnitaryRepresentation}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X86B2367A79BE5B9F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitaryRepresentation({\mdseries\slshape rho})\index{UnitaryRepresentation@\texttt{UnitaryRepresentation}}
\label{UnitaryRepresentation}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A record with fields L and unitary{\textunderscore}rep such that \mbox{\texttt{\mdseries\slshape rho}} is isomorphic to unitary{\textunderscore}rep, differing by a change of basis
L. 



 

 }

 

\subsection{\textcolor{Chapter }{IsUnitaryRepresentation}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X87D121227C027253}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsUnitaryRepresentation({\mdseries\slshape rho})\index{IsUnitaryRepresentation@\texttt{IsUnitaryRepresentation}}
\label{IsUnitaryRepresentation}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
Whether \mbox{\texttt{\mdseries\slshape rho}} is unitary, i.e. for all $g \in G$, $\rho(g^{-1}) = \rho(g)^*$ (where $^*$ denotes the conjugate transpose). 



 

 }

 

\subsection{\textcolor{Chapter }{LDLDecomposition}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X78F7DFD186A4E7CA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LDLDecomposition({\mdseries\slshape A})\index{LDLDecomposition@\texttt{LDLDecomposition}}
\label{LDLDecomposition}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a record with two fields, L and D such that $A = L\mbox{diag}(D)L^*$. $D$ is the $1 \times n$ vector which gives the diagonal matrix $\mbox{diag}(D)$ (where \mbox{\texttt{\mdseries\slshape A}} is an $n \times n$ matrix). 



 

 }

 }

 
\section{\textcolor{Chapter }{Decomposing unitary representations}}\label{Chapter_Algorithms_for_unitary_representations_Section_Decomposing_unitary_representations}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X7974D0C580C833D1}{}
{
  

\subsection{\textcolor{Chapter }{IrreducibleDecompositionDixon}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X8175C1167A31C3D6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IrreducibleDecompositionDixon({\mdseries\slshape rho})\index{IrreducibleDecompositionDixon@\texttt{IrreducibleDecompositionDixon}}
\label{IrreducibleDecompositionDixon}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list of irreps in the decomposition of \mbox{\texttt{\mdseries\slshape rho}} 



 NOTE: this is not implemented yet. Assumes that \mbox{\texttt{\mdseries\slshape rho}} is unitary and uses an algorithm due to Dixon to decompose it into unitary
irreps. }

 }

 }

   
\chapter{\textcolor{Chapter }{Miscellaneous useful functions}}\label{Chapter_Miscellaneous_useful_functions}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X8346542B8387968B}{}
{
  
\section{\textcolor{Chapter }{Predicates for representations}}\label{Chapter_Miscellaneous_useful_functions_Section_Predicates_for_representations}
\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X87196FDB78749ECA}{}
{
  

\subsection{\textcolor{Chapter }{IsFiniteGroupLinearRepresentation (for IsGroupHomomorphism)}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X8631A1417C3C1D88}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsFiniteGroupLinearRepresentation({\mdseries\slshape rho})\index{IsFiniteGroupLinearRepresentation@\texttt{IsFiniteGroupLinearRepresentation}!for IsGroupHomomorphism}
\label{IsFiniteGroupLinearRepresentation:for IsGroupHomomorphism}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
true or false 



 Tells you if \mbox{\texttt{\mdseries\slshape rho}} is a linear representation of a finite group. The algorithms implemented in
this package work on these homomorphisms only. }

 

\subsection{\textcolor{Chapter }{IsFiniteGroupPermutationRepresentation (for IsGroupHomomorphism)}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X826D5ADF7FA87782}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsFiniteGroupPermutationRepresentation({\mdseries\slshape rho})\index{IsFiniteGroupPermutationRepresentation@\texttt{IsFinite}\-\texttt{Group}\-\texttt{Permutation}\-\texttt{Representation}!for IsGroupHomomorphism}
\label{IsFiniteGroupPermutationRepresentation:for IsGroupHomomorphism}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
true or false 



 Tells you if \mbox{\texttt{\mdseries\slshape rho}} is a homomorphism from a finite group to a permutation group. }

 }

 
\section{\textcolor{Chapter }{Efficient summing over groups}}\label{Chapter_Miscellaneous_useful_functions_Section_Efficient_summing_over_groups}
\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X8271F7A386CFEA63}{}
{
  

\subsection{\textcolor{Chapter }{GroupSumBSGS}}
\logpage{[ 4, 2, 1 ]}\nobreak
\hyperdef{L}{X85E8A5FC844DC09A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{GroupSumBSGS({\mdseries\slshape G, summand})\index{GroupSumBSGS@\texttt{GroupSumBSGS}}
\label{GroupSumBSGS}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
$\sum_{g \in G} \mbox{summand}(g)$ 



 Uses a basic stabiliser chain for $G$ to compute the sum described above. This trick requires \mbox{\texttt{\mdseries\slshape summand}} to be a function (in the GAP sense) that defines a monoid homomorphism (in the
mathematical sense). The computation of the stabiliser chain assumes \mbox{\texttt{\mdseries\slshape G}} is a group. More precisely, if we have the basic stabiliser chain: 
\[\{1\} = G_1 \leq \ldots \leq G_n = G\]
 We traverse the chain from $G_1$ to $G_n$, using the previous sum $G_{i-1}$ to build the sum $G_i$. We do this by using the fact that (writing $f$ for \mbox{\texttt{\mdseries\slshape summand}}) 
\[\sum_{g \in G_i} f(g) = \sum_{r_j} \left(\sum_{h \in G_{i-1}} f(h)\right)
f(r_j)\]
 where the $r_j$ are right coset representatives of $G_{i-1}$ in $G_i$. The condition on \mbox{\texttt{\mdseries\slshape summand}} is satisfied if, for example, it is a linear representation of a group \mbox{\texttt{\mdseries\slshape G}}. }

 }

 
\section{\textcolor{Chapter }{Space-efficient representation of tensors of matrices}}\label{Chapter_Miscellaneous_useful_functions_Section_Space-efficient_representation_of_tensors_of_matrices}
\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X86F42D257CFB192D}{}
{
  Suppose we have representations of $G$, $\rho$ and $\tau$, with degree $n$ and $m$. If we would like to construct the tensor product representation of $G$, $\rho \otimes \tau$, the usual way to do it would be to take the Kronecker product of the
matrices. This means we now have to store very large $nm \times nm$ matrices for each generator of $G$. This can be avoided by storing the tensor of matrices as pairs, essentially
storing $A \otimes B$ as a pair $(A,B)$ and implementing group operations on top of these, along with some
representation-theoretic functions. It is only possible to guarantee an
economical representation for pure tensors, i.e. matrices of the form $A \otimes B$. These are closed under group operations, so it is natural to define a group
structure. 

\subsection{\textcolor{Chapter }{IsTensorProductOfMatricesObj (for IsMultiplicativeElementWithInverse)}}
\logpage{[ 4, 3, 1 ]}\nobreak
\hyperdef{L}{X84335C447DE377B0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsTensorProductOfMatricesObj({\mdseries\slshape arg})\index{IsTensorProductOfMatricesObj@\texttt{IsTensorProductOfMatricesObj}!for IsMultiplicativeElementWithInverse}
\label{IsTensorProductOfMatricesObj:for IsMultiplicativeElementWithInverse}
}\hfill{\scriptsize (filter)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false} 



 

 }

 Position $i$ in this representation stores the matrix $A_i$ in the tensor product $A_1 \otimes A_2$. 

\subsection{\textcolor{Chapter }{IsTensorProductPairRep (for IsPositionalObjectRep)}}
\logpage{[ 4, 3, 2 ]}\nobreak
\hyperdef{L}{X868B9CB1873C93AC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsTensorProductPairRep({\mdseries\slshape arg})\index{IsTensorProductPairRep@\texttt{IsTensorProductPairRep}!for IsPositionalObjectRep}
\label{IsTensorProductPairRep:for IsPositionalObjectRep}
}\hfill{\scriptsize (filter)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false} 



 

 }

 Position 1 stores the full Kronecker product of the matrices, this is very
space inefficient and supposed to be used as a last resort. 

\subsection{\textcolor{Chapter }{IsTensorProductKroneckerRep (for IsPositionalObjectRep)}}
\logpage{[ 4, 3, 3 ]}\nobreak
\hyperdef{L}{X85AD76DB7D5F8B12}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsTensorProductKroneckerRep({\mdseries\slshape arg})\index{IsTensorProductKroneckerRep@\texttt{IsTensorProductKroneckerRep}!for IsPositionalObjectRep}
\label{IsTensorProductKroneckerRep:for IsPositionalObjectRep}
}\hfill{\scriptsize (filter)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false} 



 

 }

 More convenient constructor for a tensor product (automatically handles
family) 

\subsection{\textcolor{Chapter }{TensorProductOfMatrices}}
\logpage{[ 4, 3, 4 ]}\nobreak
\hyperdef{L}{X86671AD582FF77E2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TensorProductOfMatrices({\mdseries\slshape arg})\index{TensorProductOfMatrices@\texttt{TensorProductOfMatrices}}
\label{TensorProductOfMatrices}
}\hfill{\scriptsize (function)}}\\


 

 }

 This uses the multiplicativity of characters when taking tensor products to
avoid having to compute the trace of a big matrix. 

\subsection{\textcolor{Chapter }{CharacterOfTensorProductOfRepresentations}}
\logpage{[ 4, 3, 5 ]}\nobreak
\hyperdef{L}{X79D0379D79F5DF9B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CharacterOfTensorProductOfRepresentations({\mdseries\slshape arg})\index{CharacterOfTensorProductOfRepresentations@\texttt{Character}\-\texttt{Of}\-\texttt{Tensor}\-\texttt{Product}\-\texttt{Of}\-\texttt{Representations}}
\label{CharacterOfTensorProductOfRepresentations}
}\hfill{\scriptsize (function)}}\\


 

 }

 }

 
\section{\textcolor{Chapter }{Matrices and homomorphisms}}\label{Chapter_Miscellaneous_useful_functions_Section_Matrices_and_homomorphisms}
\logpage{[ 4, 4, 0 ]}
\hyperdef{L}{X83F160967ED7EE14}{}
{
  

\subsection{\textcolor{Chapter }{BlockDiagonalMatrix}}
\logpage{[ 4, 4, 1 ]}\nobreak
\hyperdef{L}{X8668A3897972C08E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BlockDiagonalMatrix({\mdseries\slshape blocks})\index{BlockDiagonalMatrix@\texttt{BlockDiagonalMatrix}}
\label{BlockDiagonalMatrix}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
Matrix given by putting the given matrix \mbox{\texttt{\mdseries\slshape blocks}} on the diagonal 



 

 }

 

\subsection{\textcolor{Chapter }{ComposeHomFunction}}
\logpage{[ 4, 4, 2 ]}\nobreak
\hyperdef{L}{X7D17785482F143B0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ComposeHomFunction({\mdseries\slshape hom, func})\index{ComposeHomFunction@\texttt{ComposeHomFunction}}
\label{ComposeHomFunction}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
Homomorphism g given by g(x) = func(hom(x)). 



 This is mainly for convenience, since it handles all GAP accounting issues
regarding the range, ByImages vs ByFunction, etc. }

 

\subsection{\textcolor{Chapter }{Replicate}}
\logpage{[ 4, 4, 3 ]}\nobreak
\hyperdef{L}{X79D2F263840ED625}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Replicate({\mdseries\slshape elem, n})\index{Replicate@\texttt{Replicate}}
\label{Replicate}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of \mbox{\texttt{\mdseries\slshape n}} copies of \mbox{\texttt{\mdseries\slshape elem}} 



 

 }

 }

 
\section{\textcolor{Chapter }{Representation theoretic functions}}\label{Chapter_Miscellaneous_useful_functions_Section_Representation_theoretic_functions}
\logpage{[ 4, 5, 0 ]}
\hyperdef{L}{X7C3EDA5E7A24196C}{}
{
  

\subsection{\textcolor{Chapter }{TensorProductRepLists}}
\logpage{[ 4, 5, 1 ]}\nobreak
\hyperdef{L}{X841424DF824E258B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TensorProductRepLists({\mdseries\slshape list1, list2})\index{TensorProductRepLists@\texttt{TensorProductRepLists}}
\label{TensorProductRepLists}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
All possible tensor products given by $\rho \otimes \tau$ where $\rho : G \to \mbox{GL}(V)$ is taken from \mbox{\texttt{\mdseries\slshape list1}} and $\tau : H \to \mbox{GL}(W)$ is taken from \mbox{\texttt{\mdseries\slshape list2}}. The result is then a list of representations of $G \times H$. 



 

 }

 

\subsection{\textcolor{Chapter }{DirectSumOfRepresentations}}
\logpage{[ 4, 5, 2 ]}\nobreak
\hyperdef{L}{X84EAE3DB7FA8102C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DirectSumOfRepresentations({\mdseries\slshape list})\index{DirectSumOfRepresentations@\texttt{DirectSumOfRepresentations}}
\label{DirectSumOfRepresentations}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
Direct sum of the list of representations \mbox{\texttt{\mdseries\slshape list}} 



 

 }

 

\subsection{\textcolor{Chapter }{DegreeOfRepresentation}}
\logpage{[ 4, 5, 3 ]}\nobreak
\hyperdef{L}{X85147CF97B912CC3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DegreeOfRepresentation({\mdseries\slshape rho})\index{DegreeOfRepresentation@\texttt{DegreeOfRepresentation}}
\label{DegreeOfRepresentation}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
Degree of the representation \mbox{\texttt{\mdseries\slshape rho}}. That is, $\mbox{Tr}(\rho(e_G))$, where $e_G$ is the identity of the group $G$ that \mbox{\texttt{\mdseries\slshape rho}} has as domain. 



 

 }

 

\subsection{\textcolor{Chapter }{PermToLinearRep}}
\logpage{[ 4, 5, 4 ]}\nobreak
\hyperdef{L}{X7B14287E7BFC548D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PermToLinearRep({\mdseries\slshape rho})\index{PermToLinearRep@\texttt{PermToLinearRep}}
\label{PermToLinearRep}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
Linear representation $\rho$ isomorphic to the permutation representation \mbox{\texttt{\mdseries\slshape rho}}. 



 

 }

 

\subsection{\textcolor{Chapter }{IsOrthonormalSet}}
\logpage{[ 4, 5, 5 ]}\nobreak
\hyperdef{L}{X7E67A4817A5E4879}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsOrthonormalSet({\mdseries\slshape S, prod})\index{IsOrthonormalSet@\texttt{IsOrthonormalSet}}
\label{IsOrthonormalSet}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
Whether \mbox{\texttt{\mdseries\slshape S}} is an orthonormal set with respect to the inner product \mbox{\texttt{\mdseries\slshape prod}}. 



 

 }

 }

 }

   
\chapter{\textcolor{Chapter }{Computing decompositions of representations}}\label{Chapter_Computing_decompositions_of_representations}
\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X7F968DF987DE4A6E}{}
{
  
\section{\textcolor{Chapter }{Block diagonalizing}}\label{Chapter_Computing_decompositions_of_representations_Section_Block_diagonalizing}
\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X7E29883984400D2C}{}
{
  Given a representation $\rho : G \to GL(V)$, it is often desirable to find a basis for $V$ that block diagonalizes each $\rho(g)$ with the block sizes being as small as possible. This speeds up matrix algebra
operations, since they can now be done block-wise. 

\subsection{\textcolor{Chapter }{BlockDiagonalBasisOfRepresentation}}
\logpage{[ 5, 1, 1 ]}\nobreak
\hyperdef{L}{X8361AD057AD282AC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BlockDiagonalBasisOfRepresentation({\mdseries\slshape rho})\index{BlockDiagonalBasisOfRepresentation@\texttt{BlockDiagonalBasisOfRepresentation}}
\label{BlockDiagonalBasisOfRepresentation}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
Basis for $V$ that block diagonalizes $\rho$. 



 Let $G$ have irreducible representations $\rho_i$, with dimension $d_i$ and multiplicity $m_i$. The basis returned by this operation gives each $\rho(g)$ as a block diagonal matrix which has $m_i$ blocks of size $d_i \times d_i$ for each $i$. }

 

\subsection{\textcolor{Chapter }{BlockDiagonalRepresentation}}
\logpage{[ 5, 1, 2 ]}\nobreak
\hyperdef{L}{X86EB837579C1416D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BlockDiagonalRepresentation({\mdseries\slshape rho})\index{BlockDiagonalRepresentation@\texttt{BlockDiagonalRepresentation}}
\label{BlockDiagonalRepresentation}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
Representation of $G$ isomorphic to $\rho$ where the images $\rho(g)$ are block diagonalized. 



 This is just a convenience operation that uses \texttt{BlockDiagonalBasisOfRepresentation} (\ref{BlockDiagonalBasisOfRepresentation}) to calculate the basis change matrix and applies it to put $\rho$ into the block diagonalised form. }

 }

 
\section{\textcolor{Chapter }{Algorithms due to the authors}}\label{Chapter_Computing_decompositions_of_representations_Section_Algorithms_due_to_the_authors}
\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X863A16A179A7486B}{}
{
  

\subsection{\textcolor{Chapter }{REPN{\textunderscore}ComputeUsingMyMethod (for IsGroupHomomorphism)}}
\logpage{[ 5, 2, 1 ]}\nobreak
\hyperdef{L}{X831574AD864C94A8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{REPN{\textunderscore}ComputeUsingMyMethod({\mdseries\slshape rho})\index{REPNuScoreComputeUsingMyMethod@\texttt{REP}\-\texttt{N{\textunderscore}}\-\texttt{Compute}\-\texttt{Using}\-\texttt{My}\-\texttt{Method}!for IsGroupHomomorphism}
\label{REPNuScoreComputeUsingMyMethod:for IsGroupHomomorphism}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
A record in the same format as \texttt{REPN{\textunderscore}ComputeUsingSerre} (\ref{REPNuScoreComputeUsingSerre:for IsGroupHomomorphism}) 



 

 Computes the same values as \texttt{REPN{\textunderscore}ComputeUsingSerre} (\ref{REPNuScoreComputeUsingSerre:for IsGroupHomomorphism}), taking the same options. The heavy lifting of this method is done by \texttt{LinearRepresentationIsomorphism} (\ref{LinearRepresentationIsomorphism}), where there are some further options that can be passed to influence
algorithms used. }

 

\subsection{\textcolor{Chapter }{REPN{\textunderscore}ComputeUsingMyMethodCanonical (for IsGroupHomomorphism)}}
\logpage{[ 5, 2, 2 ]}\nobreak
\hyperdef{L}{X7DB659DB7E48D502}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{REPN{\textunderscore}ComputeUsingMyMethodCanonical({\mdseries\slshape rho})\index{REPNuScoreComputeUsingMyMethodCanonical@\texttt{REP}\-\texttt{N{\textunderscore}}\-\texttt{Compute}\-\texttt{Using}\-\texttt{My}\-\texttt{Method}\-\texttt{Canonical}!for IsGroupHomomorphism}
\label{REPNuScoreComputeUsingMyMethodCanonical:for IsGroupHomomorphism}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
A record in the same format as \texttt{REPN{\textunderscore}ComputeUsingMyMethod} (\ref{REPNuScoreComputeUsingMyMethod:for IsGroupHomomorphism}). 



 

 Performs the same computation as \texttt{REPN{\textunderscore}ComputeUsingMyMethod} (\ref{REPNuScoreComputeUsingMyMethod:for IsGroupHomomorphism}), but first splits the representation into canonical summands using \texttt{CanonicalDecomposition} (\ref{CanonicalDecomposition}). This might reduce the size of the matrices we need to work with
significantly, so could be much faster. 

 If the option \texttt{parallel} is given, the decomposition of canonical summands into irreps is done in
parallel, which could be much faster. }

 }

 
\section{\textcolor{Chapter }{Algorithms due to Serre}}\label{Chapter_Computing_decompositions_of_representations_Section_Algorithms_due_to_Serre}
\logpage{[ 5, 3, 0 ]}
\hyperdef{L}{X7C22F13E80A74438}{}
{
  Note: all computation in this section is actually done in the function \texttt{REPN{\textunderscore}ComputeUsingSerre} (\ref{REPNuScoreComputeUsingSerre:for IsGroupHomomorphism}), the other functions are wrappers around it. 

\subsection{\textcolor{Chapter }{CanonicalDecomposition}}
\logpage{[ 5, 3, 1 ]}\nobreak
\hyperdef{L}{X7E95B0367992BEC4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CanonicalDecomposition({\mdseries\slshape rho})\index{CanonicalDecomposition@\texttt{CanonicalDecomposition}}
\label{CanonicalDecomposition}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of vector spaces $V_i$, each $G$-invariant and a direct sum of isomorphic irreducibles. That is, for each $i$, $V_i \cong \oplus_j W_i$ (as representations) where $W_i$ is an irreducible $G$-invariant vector space. 



 Computes the canonical decomposition of $V$ into $\oplus_i\;V_i$ using the formulas for projections $V \to V_i$ due to Serre. You can pass in the option \texttt{irreps} with a list of irreps of $G$, and this will be used instead of computing a complete list ourselves. If you
already know which irreps will appear in $\rho$, for instance, this will save time. }

 

\subsection{\textcolor{Chapter }{IrreducibleDecomposition}}
\logpage{[ 5, 3, 2 ]}\nobreak
\hyperdef{L}{X795C63F386C45308}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IrreducibleDecomposition({\mdseries\slshape rho})\index{IrreducibleDecomposition@\texttt{IrreducibleDecomposition}}
\label{IrreducibleDecomposition}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of vector spaces $W_j$ such that $V = \oplus_j W_j$ and each $W_j$ is an irreducible $G$-invariant vector space. 



 Computes the decomposition of $V$ into irreducible subprepresentations. }

 

\subsection{\textcolor{Chapter }{IrreducibleDecompositionCollected}}
\logpage{[ 5, 3, 3 ]}\nobreak
\hyperdef{L}{X87E91CBE7992D126}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IrreducibleDecompositionCollected({\mdseries\slshape rho})\index{IrreducibleDecompositionCollected@\texttt{IrreducibleDecompositionCollected}}
\label{IrreducibleDecompositionCollected}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of lists $V_i$ of vector spaces $V_{ij}$ such that $V = \oplus_i \oplus_j V_{ij}$ and $V_{ik} \cong V_{il}$ for all $i$, $k$ and $l$ (as representations). 



 Computes the decomposition of $V$ into irreducible subrepresentations, grouping together the isomorphic
subrepresentations. }

 

\subsection{\textcolor{Chapter }{REPN{\textunderscore}ComputeUsingSerre (for IsGroupHomomorphism)}}
\logpage{[ 5, 3, 4 ]}\nobreak
\hyperdef{L}{X7C1CF0547D72D354}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{REPN{\textunderscore}ComputeUsingSerre({\mdseries\slshape rho})\index{REPNuScoreComputeUsingSerre@\texttt{REP}\-\texttt{N{\textunderscore}}\-\texttt{Compute}\-\texttt{Using}\-\texttt{Serre}!for IsGroupHomomorphism}
\label{REPNuScoreComputeUsingSerre:for IsGroupHomomorphism}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
A record, in the format described below 



 This function does all of the computation and (since it is an attribute) saves
the results. Doing all of the calculations at the same time ensures
consistency when it comes to irrep ordering, block ordering and basis
ordering. There is no canonical ordering of irreps, so this is crucial. 

 \mbox{\texttt{\mdseries\slshape irreps}} is the complete list of irreps involved in the direct sum decomposition of \mbox{\texttt{\mdseries\slshape rho}}, this can be given in case the default (running Dixon's algorithm) is too
expensive, or e.g. you don't want representations over Cyclotomics. 

 The return value of this function is a record with fields: 

 
\begin{itemize}
\item  \texttt{basis}: The basis that block diagonalises $\rho$, see \texttt{BlockDiagonalBasisOfRepresentation} (\ref{BlockDiagonalBasisOfRepresentation}). 
\end{itemize}
 

 
\begin{itemize}
\item  \texttt{diagonal{\textunderscore}rep}: $\rho$, block diagonalised with the basis above. See \texttt{BlockDiagonalRepresentation} (\ref{BlockDiagonalRepresentation}) 
\end{itemize}
 

 
\begin{itemize}
\item  \texttt{decomposition}: The irreducible $G$-invariant subspaces, collected according to isomorphism, see \texttt{IrreducibleDecompositionCollected} (\ref{IrreducibleDecompositionCollected}) 
\end{itemize}
 

 
\begin{itemize}
\item  \texttt{centralizer{\textunderscore}basis}: An orthonormal basis for the centralizer ring of $\rho$, written in block form. See \texttt{CentralizerBlocksOfRepresentation} (\ref{CentralizerBlocksOfRepresentation}) 
\end{itemize}
 

 Pass the option \texttt{parallel} for the computations per-irrep to be done in parallel. 

 Pass the option \texttt{irreps} with the complete list of irreps of $\rho$ to avoid recomputing this list (could be very expensive) }

 }

 }

   
\chapter{\textcolor{Chapter }{Centralizer (commutant) rings}}\label{Chapter_Centralizer_commutant_rings}
\logpage{[ 6, 0, 0 ]}
\hyperdef{L}{X7A0EF2C67E2DB726}{}
{
  
\section{\textcolor{Chapter }{Finding a basis for the centralizer}}\label{Chapter_Centralizer_commutant_rings_Section_Finding_a_basis_for_the_centralizer}
\logpage{[ 6, 1, 0 ]}
\hyperdef{L}{X7E70A3D881CD5FFA}{}
{
  

\subsection{\textcolor{Chapter }{CentralizerBlocksOfRepresentation}}
\logpage{[ 6, 1, 1 ]}\nobreak
\hyperdef{L}{X7901B6A7860D35C3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CentralizerBlocksOfRepresentation({\mdseries\slshape rho})\index{CentralizerBlocksOfRepresentation@\texttt{CentralizerBlocksOfRepresentation}}
\label{CentralizerBlocksOfRepresentation}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of vector space generators for the centralizer ring of $\rho(G)$, written in the basis given by \texttt{BlockDiagonalBasisOfRepresentation} (\ref{BlockDiagonalBasisOfRepresentation}). The matrices are given as a list of blocks. 



 Let $G$ have irreducible representations $\rho_i$ with multiplicities $m_i$. The centralizer has dimension $\sum_i m_i^2$ as a $\mathbb{C}$-vector space. This function gives the minimal number of generators required. }

 

\subsection{\textcolor{Chapter }{CentralizerOfRepresentation}}
\logpage{[ 6, 1, 2 ]}\nobreak
\hyperdef{L}{X86B19E2B877121E9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CentralizerOfRepresentation({\mdseries\slshape arg})\index{CentralizerOfRepresentation@\texttt{CentralizerOfRepresentation}}
\label{CentralizerOfRepresentation}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of vector space generators for the centralizer ring of $\rho(G)$. 



 This gives the same result as \texttt{CentralizerBlocksOfRepresentation} (\ref{CentralizerBlocksOfRepresentation}), but with the matrices given in their entirety: not as lists of blocks, but
as full matrices. }

 }

 
\section{\textcolor{Chapter }{Using the centralizer for computations}}\label{Chapter_Centralizer_commutant_rings_Section_Using_the_centralizer_for_computations}
\logpage{[ 6, 2, 0 ]}
\hyperdef{L}{X83C4F8C17DA976EE}{}
{
  

\subsection{\textcolor{Chapter }{ClassSumCentralizer}}
\logpage{[ 6, 2, 1 ]}\nobreak
\hyperdef{L}{X87E5BAEB82DC00C3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ClassSumCentralizer({\mdseries\slshape rho, class, cent{\textunderscore}basis})\index{ClassSumCentralizer@\texttt{ClassSumCentralizer}}
\label{ClassSumCentralizer}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
$\sum_{s \in t^G} \rho(s)$, where $t$ is a representative of the conjugacy class \mbox{\texttt{\mdseries\slshape class}} of $G$. 



 We require that \mbox{\texttt{\mdseries\slshape rho}} is unitary. Uses the given orthonormal basis (with respect to the inner
product $\langle A, B \rangle = \mbox{Trace}(AB^*)$) for the centralizer ring of \mbox{\texttt{\mdseries\slshape rho}} to calculate the sum of the conjugacy class \mbox{\texttt{\mdseries\slshape class}} quickly, i.e. without summing over the class. NOTE: Orthonormality of \mbox{\texttt{\mdseries\slshape cent{\textunderscore}basis}} and unitarity of \mbox{\texttt{\mdseries\slshape rho}} are checked. See \texttt{ClassSumCentralizerNC} (\ref{ClassSumCentralizerNC}) for a version of this function without checks. The checks are not very
expensive, so it is recommended you use the function with checks. }

 

\subsection{\textcolor{Chapter }{ClassSumCentralizerNC}}
\logpage{[ 6, 2, 2 ]}\nobreak
\hyperdef{L}{X78719DC8868B0744}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ClassSumCentralizerNC({\mdseries\slshape rho, class, cent{\textunderscore}basis})\index{ClassSumCentralizerNC@\texttt{ClassSumCentralizerNC}}
\label{ClassSumCentralizerNC}
}\hfill{\scriptsize (function)}}\\


 The same as \texttt{ClassSumCentralizer} (\ref{ClassSumCentralizer}), but does not check the basis for orthonormality or the representation for
unitarity. }

 }

 }

 \def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\immediate\write\pagenrlog{["Ind", 0, 0], \arabic{page},}
\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
