<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_RepnDecomp_automatic_generated_documentation">
<Heading>RepnDecomp automatic generated documentation</Heading>

<Section Label="Chapter_RepnDecomp_automatic_generated_documentation_Section_RepnDecomp_automatic_generated_documentation_of_global_functions">
<Heading>RepnDecomp automatic generated documentation of global functions</Heading>

<ManSection>
  <Func Arg="G, summand" Name="GroupSumBSGS" />
 <Returns><Math>\sum_{g \in G} \text{summand}(g)</Math>
</Returns>
 <Description>
Uses a basic stabiliser chain for <Math>G</Math> to compute the
sum described above. This trick requires <A>summand</A> to be a
function (in the GAP sense) that defines a monoid homomorphism (in
the mathematical sense). The computation of the stabiliser chain
assumes <A>G</A> is a group.
More precisely, if we have the basic stabiliser chain:
<Display>\{1\} = G_1 \leq \ldots \leq G_n = G</Display>
We traverse the chain from <Math>G_1</Math> to <Math>G_n</Math>, using the previous sum
<Math>G_{i-1}</Math> to build the sum <Math>G_i</Math>. We do this by using the fact
that (writing <Math>f</Math> for <A>summand</A>)
<Display>\sum_{g \in G_i} f(g) = \sum_{r_j} (\sum_{h \in G_{i-1}} f(h)) f(r_j)</Display>
where the <Math>r_j</Math> are right coset representatives of <Math>G_{i-1}</Math> in
<Math>G_i</Math>.
The condition on <A>summand</A> is satisfied if, for example, it is
a linear representation of a group <A>G</A>.
 </Description>
</ManSection>


</Section>


</Chapter>

